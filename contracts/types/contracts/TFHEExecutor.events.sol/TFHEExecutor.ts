/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  EventFragment,
  AddressLike,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedLogDescription,
  TypedListener,
  TypedContractMethod,
} from "../../common";

export interface TFHEExecutorInterface extends Interface {
  getFunction(
    nameOrSignature:
      | "HANDLE_VERSION"
      | "UPGRADE_INTERFACE_VERSION"
      | "acceptOwnership"
      | "cast"
      | "fheAdd"
      | "fheBitAnd"
      | "fheBitOr"
      | "fheBitXor"
      | "fheDiv"
      | "fheEq(uint256,uint256,bytes1)"
      | "fheEq(uint256,bytes,bytes1)"
      | "fheGe"
      | "fheGt"
      | "fheIfThenElse"
      | "fheLe"
      | "fheLt"
      | "fheMax"
      | "fheMin"
      | "fheMul"
      | "fheNe(uint256,bytes,bytes1)"
      | "fheNe(uint256,uint256,bytes1)"
      | "fheNeg"
      | "fheNot"
      | "fheRand"
      | "fheRandBounded"
      | "fheRem"
      | "fheRotl"
      | "fheRotr"
      | "fheShl"
      | "fheShr"
      | "fheSub"
      | "getACLAddress"
      | "getFHEPaymentAddress"
      | "getInputVerifierAddress"
      | "getVersion"
      | "initialize"
      | "owner"
      | "pendingOwner"
      | "proxiableUUID"
      | "renounceOwnership"
      | "transferOwnership"
      | "trivialEncrypt(bytes,bytes1)"
      | "trivialEncrypt(uint256,bytes1)"
      | "upgradeToAndCall"
      | "verifyCiphertext"
  ): FunctionFragment;

  getEvent(
    nameOrSignatureOrTopic:
      | "Cast"
      | "FheAdd"
      | "FheBitAnd"
      | "FheBitOr"
      | "FheBitXor"
      | "FheDiv"
      | "FheEq"
      | "FheEqBytes"
      | "FheGe"
      | "FheGt"
      | "FheIfThenElse"
      | "FheLe"
      | "FheLt"
      | "FheMax"
      | "FheMin"
      | "FheMul"
      | "FheNe"
      | "FheNeBytes"
      | "FheNeg"
      | "FheNot"
      | "FheRand"
      | "FheRandBounded"
      | "FheRem"
      | "FheRotl"
      | "FheRotr"
      | "FheShl"
      | "FheShr"
      | "FheSub"
      | "Initialized"
      | "OwnershipTransferStarted"
      | "OwnershipTransferred"
      | "TrivialEncrypt"
      | "TrivialEncryptBytes"
      | "Upgraded"
      | "VerifyCiphertext"
  ): EventFragment;

  encodeFunctionData(
    functionFragment: "HANDLE_VERSION",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "UPGRADE_INTERFACE_VERSION",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "acceptOwnership",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "cast",
    values: [BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "fheAdd",
    values: [BigNumberish, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "fheBitAnd",
    values: [BigNumberish, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "fheBitOr",
    values: [BigNumberish, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "fheBitXor",
    values: [BigNumberish, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "fheDiv",
    values: [BigNumberish, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "fheEq(uint256,uint256,bytes1)",
    values: [BigNumberish, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "fheEq(uint256,bytes,bytes1)",
    values: [BigNumberish, BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "fheGe",
    values: [BigNumberish, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "fheGt",
    values: [BigNumberish, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "fheIfThenElse",
    values: [BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "fheLe",
    values: [BigNumberish, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "fheLt",
    values: [BigNumberish, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "fheMax",
    values: [BigNumberish, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "fheMin",
    values: [BigNumberish, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "fheMul",
    values: [BigNumberish, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "fheNe(uint256,bytes,bytes1)",
    values: [BigNumberish, BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "fheNe(uint256,uint256,bytes1)",
    values: [BigNumberish, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "fheNeg",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "fheNot",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "fheRand", values: [BytesLike]): string;
  encodeFunctionData(
    functionFragment: "fheRandBounded",
    values: [BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "fheRem",
    values: [BigNumberish, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "fheRotl",
    values: [BigNumberish, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "fheRotr",
    values: [BigNumberish, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "fheShl",
    values: [BigNumberish, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "fheShr",
    values: [BigNumberish, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "fheSub",
    values: [BigNumberish, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getACLAddress",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getFHEPaymentAddress",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getInputVerifierAddress",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getVersion",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "initialize",
    values: [AddressLike]
  ): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "pendingOwner",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "proxiableUUID",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "renounceOwnership",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "transferOwnership",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "trivialEncrypt(bytes,bytes1)",
    values: [BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "trivialEncrypt(uint256,bytes1)",
    values: [BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "upgradeToAndCall",
    values: [AddressLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "verifyCiphertext",
    values: [BytesLike, AddressLike, BytesLike, BytesLike]
  ): string;

  decodeFunctionResult(
    functionFragment: "HANDLE_VERSION",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "UPGRADE_INTERFACE_VERSION",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "acceptOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "cast", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fheAdd", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fheBitAnd", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fheBitOr", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fheBitXor", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fheDiv", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "fheEq(uint256,uint256,bytes1)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "fheEq(uint256,bytes,bytes1)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "fheGe", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fheGt", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "fheIfThenElse",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "fheLe", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fheLt", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fheMax", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fheMin", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fheMul", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "fheNe(uint256,bytes,bytes1)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "fheNe(uint256,uint256,bytes1)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "fheNeg", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fheNot", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fheRand", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "fheRandBounded",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "fheRem", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fheRotl", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fheRotr", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fheShl", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fheShr", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fheSub", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getACLAddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getFHEPaymentAddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getInputVerifierAddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getVersion", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "initialize", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "pendingOwner",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "proxiableUUID",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "renounceOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "trivialEncrypt(bytes,bytes1)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "trivialEncrypt(uint256,bytes1)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "upgradeToAndCall",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "verifyCiphertext",
    data: BytesLike
  ): Result;
}

export namespace CastEvent {
  export type InputTuple = [
    ct: BigNumberish,
    toType: BytesLike,
    result: BigNumberish
  ];
  export type OutputTuple = [ct: bigint, toType: string, result: bigint];
  export interface OutputObject {
    ct: bigint;
    toType: string;
    result: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FheAddEvent {
  export type InputTuple = [
    lhs: BigNumberish,
    rhs: BigNumberish,
    scalarByte: BytesLike,
    result: BigNumberish
  ];
  export type OutputTuple = [
    lhs: bigint,
    rhs: bigint,
    scalarByte: string,
    result: bigint
  ];
  export interface OutputObject {
    lhs: bigint;
    rhs: bigint;
    scalarByte: string;
    result: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FheBitAndEvent {
  export type InputTuple = [
    lhs: BigNumberish,
    rhs: BigNumberish,
    scalarByte: BytesLike,
    result: BigNumberish
  ];
  export type OutputTuple = [
    lhs: bigint,
    rhs: bigint,
    scalarByte: string,
    result: bigint
  ];
  export interface OutputObject {
    lhs: bigint;
    rhs: bigint;
    scalarByte: string;
    result: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FheBitOrEvent {
  export type InputTuple = [
    lhs: BigNumberish,
    rhs: BigNumberish,
    scalarByte: BytesLike,
    result: BigNumberish
  ];
  export type OutputTuple = [
    lhs: bigint,
    rhs: bigint,
    scalarByte: string,
    result: bigint
  ];
  export interface OutputObject {
    lhs: bigint;
    rhs: bigint;
    scalarByte: string;
    result: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FheBitXorEvent {
  export type InputTuple = [
    lhs: BigNumberish,
    rhs: BigNumberish,
    scalarByte: BytesLike,
    result: BigNumberish
  ];
  export type OutputTuple = [
    lhs: bigint,
    rhs: bigint,
    scalarByte: string,
    result: bigint
  ];
  export interface OutputObject {
    lhs: bigint;
    rhs: bigint;
    scalarByte: string;
    result: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FheDivEvent {
  export type InputTuple = [
    lhs: BigNumberish,
    rhs: BigNumberish,
    scalarByte: BytesLike,
    result: BigNumberish
  ];
  export type OutputTuple = [
    lhs: bigint,
    rhs: bigint,
    scalarByte: string,
    result: bigint
  ];
  export interface OutputObject {
    lhs: bigint;
    rhs: bigint;
    scalarByte: string;
    result: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FheEqEvent {
  export type InputTuple = [
    lhs: BigNumberish,
    rhs: BigNumberish,
    scalarByte: BytesLike,
    result: BigNumberish
  ];
  export type OutputTuple = [
    lhs: bigint,
    rhs: bigint,
    scalarByte: string,
    result: bigint
  ];
  export interface OutputObject {
    lhs: bigint;
    rhs: bigint;
    scalarByte: string;
    result: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FheEqBytesEvent {
  export type InputTuple = [
    lhs: BigNumberish,
    rhs: BytesLike,
    scalarByte: BytesLike,
    result: BigNumberish
  ];
  export type OutputTuple = [
    lhs: bigint,
    rhs: string,
    scalarByte: string,
    result: bigint
  ];
  export interface OutputObject {
    lhs: bigint;
    rhs: string;
    scalarByte: string;
    result: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FheGeEvent {
  export type InputTuple = [
    lhs: BigNumberish,
    rhs: BigNumberish,
    scalarByte: BytesLike,
    result: BigNumberish
  ];
  export type OutputTuple = [
    lhs: bigint,
    rhs: bigint,
    scalarByte: string,
    result: bigint
  ];
  export interface OutputObject {
    lhs: bigint;
    rhs: bigint;
    scalarByte: string;
    result: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FheGtEvent {
  export type InputTuple = [
    lhs: BigNumberish,
    rhs: BigNumberish,
    scalarByte: BytesLike,
    result: BigNumberish
  ];
  export type OutputTuple = [
    lhs: bigint,
    rhs: bigint,
    scalarByte: string,
    result: bigint
  ];
  export interface OutputObject {
    lhs: bigint;
    rhs: bigint;
    scalarByte: string;
    result: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FheIfThenElseEvent {
  export type InputTuple = [
    control: BigNumberish,
    ifTrue: BigNumberish,
    ifFalse: BigNumberish,
    result: BigNumberish
  ];
  export type OutputTuple = [
    control: bigint,
    ifTrue: bigint,
    ifFalse: bigint,
    result: bigint
  ];
  export interface OutputObject {
    control: bigint;
    ifTrue: bigint;
    ifFalse: bigint;
    result: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FheLeEvent {
  export type InputTuple = [
    lhs: BigNumberish,
    rhs: BigNumberish,
    scalarByte: BytesLike,
    result: BigNumberish
  ];
  export type OutputTuple = [
    lhs: bigint,
    rhs: bigint,
    scalarByte: string,
    result: bigint
  ];
  export interface OutputObject {
    lhs: bigint;
    rhs: bigint;
    scalarByte: string;
    result: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FheLtEvent {
  export type InputTuple = [
    lhs: BigNumberish,
    rhs: BigNumberish,
    scalarByte: BytesLike,
    result: BigNumberish
  ];
  export type OutputTuple = [
    lhs: bigint,
    rhs: bigint,
    scalarByte: string,
    result: bigint
  ];
  export interface OutputObject {
    lhs: bigint;
    rhs: bigint;
    scalarByte: string;
    result: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FheMaxEvent {
  export type InputTuple = [
    lhs: BigNumberish,
    rhs: BigNumberish,
    scalarByte: BytesLike,
    result: BigNumberish
  ];
  export type OutputTuple = [
    lhs: bigint,
    rhs: bigint,
    scalarByte: string,
    result: bigint
  ];
  export interface OutputObject {
    lhs: bigint;
    rhs: bigint;
    scalarByte: string;
    result: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FheMinEvent {
  export type InputTuple = [
    lhs: BigNumberish,
    rhs: BigNumberish,
    scalarByte: BytesLike,
    result: BigNumberish
  ];
  export type OutputTuple = [
    lhs: bigint,
    rhs: bigint,
    scalarByte: string,
    result: bigint
  ];
  export interface OutputObject {
    lhs: bigint;
    rhs: bigint;
    scalarByte: string;
    result: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FheMulEvent {
  export type InputTuple = [
    lhs: BigNumberish,
    rhs: BigNumberish,
    scalarByte: BytesLike,
    result: BigNumberish
  ];
  export type OutputTuple = [
    lhs: bigint,
    rhs: bigint,
    scalarByte: string,
    result: bigint
  ];
  export interface OutputObject {
    lhs: bigint;
    rhs: bigint;
    scalarByte: string;
    result: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FheNeEvent {
  export type InputTuple = [
    lhs: BigNumberish,
    rhs: BigNumberish,
    scalarByte: BytesLike,
    result: BigNumberish
  ];
  export type OutputTuple = [
    lhs: bigint,
    rhs: bigint,
    scalarByte: string,
    result: bigint
  ];
  export interface OutputObject {
    lhs: bigint;
    rhs: bigint;
    scalarByte: string;
    result: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FheNeBytesEvent {
  export type InputTuple = [
    lhs: BigNumberish,
    rhs: BytesLike,
    scalarByte: BytesLike,
    result: BigNumberish
  ];
  export type OutputTuple = [
    lhs: bigint,
    rhs: string,
    scalarByte: string,
    result: bigint
  ];
  export interface OutputObject {
    lhs: bigint;
    rhs: string;
    scalarByte: string;
    result: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FheNegEvent {
  export type InputTuple = [ct: BigNumberish, result: BigNumberish];
  export type OutputTuple = [ct: bigint, result: bigint];
  export interface OutputObject {
    ct: bigint;
    result: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FheNotEvent {
  export type InputTuple = [ct: BigNumberish, result: BigNumberish];
  export type OutputTuple = [ct: bigint, result: bigint];
  export interface OutputObject {
    ct: bigint;
    result: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FheRandEvent {
  export type InputTuple = [randType: BytesLike, result: BigNumberish];
  export type OutputTuple = [randType: string, result: bigint];
  export interface OutputObject {
    randType: string;
    result: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FheRandBoundedEvent {
  export type InputTuple = [
    upperBound: BigNumberish,
    randType: BytesLike,
    result: BigNumberish
  ];
  export type OutputTuple = [
    upperBound: bigint,
    randType: string,
    result: bigint
  ];
  export interface OutputObject {
    upperBound: bigint;
    randType: string;
    result: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FheRemEvent {
  export type InputTuple = [
    lhs: BigNumberish,
    rhs: BigNumberish,
    scalarByte: BytesLike,
    result: BigNumberish
  ];
  export type OutputTuple = [
    lhs: bigint,
    rhs: bigint,
    scalarByte: string,
    result: bigint
  ];
  export interface OutputObject {
    lhs: bigint;
    rhs: bigint;
    scalarByte: string;
    result: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FheRotlEvent {
  export type InputTuple = [
    lhs: BigNumberish,
    rhs: BigNumberish,
    scalarByte: BytesLike,
    result: BigNumberish
  ];
  export type OutputTuple = [
    lhs: bigint,
    rhs: bigint,
    scalarByte: string,
    result: bigint
  ];
  export interface OutputObject {
    lhs: bigint;
    rhs: bigint;
    scalarByte: string;
    result: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FheRotrEvent {
  export type InputTuple = [
    lhs: BigNumberish,
    rhs: BigNumberish,
    scalarByte: BytesLike,
    result: BigNumberish
  ];
  export type OutputTuple = [
    lhs: bigint,
    rhs: bigint,
    scalarByte: string,
    result: bigint
  ];
  export interface OutputObject {
    lhs: bigint;
    rhs: bigint;
    scalarByte: string;
    result: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FheShlEvent {
  export type InputTuple = [
    lhs: BigNumberish,
    rhs: BigNumberish,
    scalarByte: BytesLike,
    result: BigNumberish
  ];
  export type OutputTuple = [
    lhs: bigint,
    rhs: bigint,
    scalarByte: string,
    result: bigint
  ];
  export interface OutputObject {
    lhs: bigint;
    rhs: bigint;
    scalarByte: string;
    result: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FheShrEvent {
  export type InputTuple = [
    lhs: BigNumberish,
    rhs: BigNumberish,
    scalarByte: BytesLike,
    result: BigNumberish
  ];
  export type OutputTuple = [
    lhs: bigint,
    rhs: bigint,
    scalarByte: string,
    result: bigint
  ];
  export interface OutputObject {
    lhs: bigint;
    rhs: bigint;
    scalarByte: string;
    result: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FheSubEvent {
  export type InputTuple = [
    lhs: BigNumberish,
    rhs: BigNumberish,
    scalarByte: BytesLike,
    result: BigNumberish
  ];
  export type OutputTuple = [
    lhs: bigint,
    rhs: bigint,
    scalarByte: string,
    result: bigint
  ];
  export interface OutputObject {
    lhs: bigint;
    rhs: bigint;
    scalarByte: string;
    result: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace InitializedEvent {
  export type InputTuple = [version: BigNumberish];
  export type OutputTuple = [version: bigint];
  export interface OutputObject {
    version: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace OwnershipTransferStartedEvent {
  export type InputTuple = [previousOwner: AddressLike, newOwner: AddressLike];
  export type OutputTuple = [previousOwner: string, newOwner: string];
  export interface OutputObject {
    previousOwner: string;
    newOwner: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace OwnershipTransferredEvent {
  export type InputTuple = [previousOwner: AddressLike, newOwner: AddressLike];
  export type OutputTuple = [previousOwner: string, newOwner: string];
  export interface OutputObject {
    previousOwner: string;
    newOwner: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace TrivialEncryptEvent {
  export type InputTuple = [
    pt: BigNumberish,
    toType: BytesLike,
    result: BigNumberish
  ];
  export type OutputTuple = [pt: bigint, toType: string, result: bigint];
  export interface OutputObject {
    pt: bigint;
    toType: string;
    result: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace TrivialEncryptBytesEvent {
  export type InputTuple = [
    pt: BytesLike,
    toType: BytesLike,
    result: BigNumberish
  ];
  export type OutputTuple = [pt: string, toType: string, result: bigint];
  export interface OutputObject {
    pt: string;
    toType: string;
    result: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace UpgradedEvent {
  export type InputTuple = [implementation: AddressLike];
  export type OutputTuple = [implementation: string];
  export interface OutputObject {
    implementation: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace VerifyCiphertextEvent {
  export type InputTuple = [
    inputHandle: BytesLike,
    userAddress: AddressLike,
    inputProof: BytesLike,
    inputType: BytesLike,
    result: BigNumberish
  ];
  export type OutputTuple = [
    inputHandle: string,
    userAddress: string,
    inputProof: string,
    inputType: string,
    result: bigint
  ];
  export interface OutputObject {
    inputHandle: string;
    userAddress: string;
    inputProof: string;
    inputType: string;
    result: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export interface TFHEExecutor extends BaseContract {
  connect(runner?: ContractRunner | null): TFHEExecutor;
  waitForDeployment(): Promise<this>;

  interface: TFHEExecutorInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  HANDLE_VERSION: TypedContractMethod<[], [bigint], "view">;

  UPGRADE_INTERFACE_VERSION: TypedContractMethod<[], [string], "view">;

  acceptOwnership: TypedContractMethod<[], [void], "nonpayable">;

  cast: TypedContractMethod<
    [ct: BigNumberish, toType: BytesLike],
    [bigint],
    "nonpayable"
  >;

  fheAdd: TypedContractMethod<
    [lhs: BigNumberish, rhs: BigNumberish, scalarByte: BytesLike],
    [bigint],
    "nonpayable"
  >;

  fheBitAnd: TypedContractMethod<
    [lhs: BigNumberish, rhs: BigNumberish, scalarByte: BytesLike],
    [bigint],
    "nonpayable"
  >;

  fheBitOr: TypedContractMethod<
    [lhs: BigNumberish, rhs: BigNumberish, scalarByte: BytesLike],
    [bigint],
    "nonpayable"
  >;

  fheBitXor: TypedContractMethod<
    [lhs: BigNumberish, rhs: BigNumberish, scalarByte: BytesLike],
    [bigint],
    "nonpayable"
  >;

  fheDiv: TypedContractMethod<
    [lhs: BigNumberish, rhs: BigNumberish, scalarByte: BytesLike],
    [bigint],
    "nonpayable"
  >;

  "fheEq(uint256,uint256,bytes1)": TypedContractMethod<
    [lhs: BigNumberish, rhs: BigNumberish, scalarByte: BytesLike],
    [bigint],
    "nonpayable"
  >;

  "fheEq(uint256,bytes,bytes1)": TypedContractMethod<
    [lhs: BigNumberish, rhs: BytesLike, scalarByte: BytesLike],
    [bigint],
    "nonpayable"
  >;

  fheGe: TypedContractMethod<
    [lhs: BigNumberish, rhs: BigNumberish, scalarByte: BytesLike],
    [bigint],
    "nonpayable"
  >;

  fheGt: TypedContractMethod<
    [lhs: BigNumberish, rhs: BigNumberish, scalarByte: BytesLike],
    [bigint],
    "nonpayable"
  >;

  fheIfThenElse: TypedContractMethod<
    [control: BigNumberish, ifTrue: BigNumberish, ifFalse: BigNumberish],
    [bigint],
    "nonpayable"
  >;

  fheLe: TypedContractMethod<
    [lhs: BigNumberish, rhs: BigNumberish, scalarByte: BytesLike],
    [bigint],
    "nonpayable"
  >;

  fheLt: TypedContractMethod<
    [lhs: BigNumberish, rhs: BigNumberish, scalarByte: BytesLike],
    [bigint],
    "nonpayable"
  >;

  fheMax: TypedContractMethod<
    [lhs: BigNumberish, rhs: BigNumberish, scalarByte: BytesLike],
    [bigint],
    "nonpayable"
  >;

  fheMin: TypedContractMethod<
    [lhs: BigNumberish, rhs: BigNumberish, scalarByte: BytesLike],
    [bigint],
    "nonpayable"
  >;

  fheMul: TypedContractMethod<
    [lhs: BigNumberish, rhs: BigNumberish, scalarByte: BytesLike],
    [bigint],
    "nonpayable"
  >;

  "fheNe(uint256,bytes,bytes1)": TypedContractMethod<
    [lhs: BigNumberish, rhs: BytesLike, scalarByte: BytesLike],
    [bigint],
    "nonpayable"
  >;

  "fheNe(uint256,uint256,bytes1)": TypedContractMethod<
    [lhs: BigNumberish, rhs: BigNumberish, scalarByte: BytesLike],
    [bigint],
    "nonpayable"
  >;

  fheNeg: TypedContractMethod<[ct: BigNumberish], [bigint], "nonpayable">;

  fheNot: TypedContractMethod<[ct: BigNumberish], [bigint], "nonpayable">;

  fheRand: TypedContractMethod<[randType: BytesLike], [bigint], "nonpayable">;

  fheRandBounded: TypedContractMethod<
    [upperBound: BigNumberish, randType: BytesLike],
    [bigint],
    "nonpayable"
  >;

  fheRem: TypedContractMethod<
    [lhs: BigNumberish, rhs: BigNumberish, scalarByte: BytesLike],
    [bigint],
    "nonpayable"
  >;

  fheRotl: TypedContractMethod<
    [lhs: BigNumberish, rhs: BigNumberish, scalarByte: BytesLike],
    [bigint],
    "nonpayable"
  >;

  fheRotr: TypedContractMethod<
    [lhs: BigNumberish, rhs: BigNumberish, scalarByte: BytesLike],
    [bigint],
    "nonpayable"
  >;

  fheShl: TypedContractMethod<
    [lhs: BigNumberish, rhs: BigNumberish, scalarByte: BytesLike],
    [bigint],
    "nonpayable"
  >;

  fheShr: TypedContractMethod<
    [lhs: BigNumberish, rhs: BigNumberish, scalarByte: BytesLike],
    [bigint],
    "nonpayable"
  >;

  fheSub: TypedContractMethod<
    [lhs: BigNumberish, rhs: BigNumberish, scalarByte: BytesLike],
    [bigint],
    "nonpayable"
  >;

  getACLAddress: TypedContractMethod<[], [string], "view">;

  getFHEPaymentAddress: TypedContractMethod<[], [string], "view">;

  getInputVerifierAddress: TypedContractMethod<[], [string], "view">;

  getVersion: TypedContractMethod<[], [string], "view">;

  initialize: TypedContractMethod<
    [initialOwner: AddressLike],
    [void],
    "nonpayable"
  >;

  owner: TypedContractMethod<[], [string], "view">;

  pendingOwner: TypedContractMethod<[], [string], "view">;

  proxiableUUID: TypedContractMethod<[], [string], "view">;

  renounceOwnership: TypedContractMethod<[], [void], "nonpayable">;

  transferOwnership: TypedContractMethod<
    [newOwner: AddressLike],
    [void],
    "nonpayable"
  >;

  "trivialEncrypt(bytes,bytes1)": TypedContractMethod<
    [pt: BytesLike, toType: BytesLike],
    [bigint],
    "nonpayable"
  >;

  "trivialEncrypt(uint256,bytes1)": TypedContractMethod<
    [pt: BigNumberish, toType: BytesLike],
    [bigint],
    "nonpayable"
  >;

  upgradeToAndCall: TypedContractMethod<
    [newImplementation: AddressLike, data: BytesLike],
    [void],
    "payable"
  >;

  verifyCiphertext: TypedContractMethod<
    [
      inputHandle: BytesLike,
      userAddress: AddressLike,
      inputProof: BytesLike,
      inputType: BytesLike
    ],
    [bigint],
    "nonpayable"
  >;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "HANDLE_VERSION"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "UPGRADE_INTERFACE_VERSION"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "acceptOwnership"
  ): TypedContractMethod<[], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "cast"
  ): TypedContractMethod<
    [ct: BigNumberish, toType: BytesLike],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "fheAdd"
  ): TypedContractMethod<
    [lhs: BigNumberish, rhs: BigNumberish, scalarByte: BytesLike],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "fheBitAnd"
  ): TypedContractMethod<
    [lhs: BigNumberish, rhs: BigNumberish, scalarByte: BytesLike],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "fheBitOr"
  ): TypedContractMethod<
    [lhs: BigNumberish, rhs: BigNumberish, scalarByte: BytesLike],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "fheBitXor"
  ): TypedContractMethod<
    [lhs: BigNumberish, rhs: BigNumberish, scalarByte: BytesLike],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "fheDiv"
  ): TypedContractMethod<
    [lhs: BigNumberish, rhs: BigNumberish, scalarByte: BytesLike],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "fheEq(uint256,uint256,bytes1)"
  ): TypedContractMethod<
    [lhs: BigNumberish, rhs: BigNumberish, scalarByte: BytesLike],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "fheEq(uint256,bytes,bytes1)"
  ): TypedContractMethod<
    [lhs: BigNumberish, rhs: BytesLike, scalarByte: BytesLike],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "fheGe"
  ): TypedContractMethod<
    [lhs: BigNumberish, rhs: BigNumberish, scalarByte: BytesLike],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "fheGt"
  ): TypedContractMethod<
    [lhs: BigNumberish, rhs: BigNumberish, scalarByte: BytesLike],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "fheIfThenElse"
  ): TypedContractMethod<
    [control: BigNumberish, ifTrue: BigNumberish, ifFalse: BigNumberish],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "fheLe"
  ): TypedContractMethod<
    [lhs: BigNumberish, rhs: BigNumberish, scalarByte: BytesLike],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "fheLt"
  ): TypedContractMethod<
    [lhs: BigNumberish, rhs: BigNumberish, scalarByte: BytesLike],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "fheMax"
  ): TypedContractMethod<
    [lhs: BigNumberish, rhs: BigNumberish, scalarByte: BytesLike],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "fheMin"
  ): TypedContractMethod<
    [lhs: BigNumberish, rhs: BigNumberish, scalarByte: BytesLike],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "fheMul"
  ): TypedContractMethod<
    [lhs: BigNumberish, rhs: BigNumberish, scalarByte: BytesLike],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "fheNe(uint256,bytes,bytes1)"
  ): TypedContractMethod<
    [lhs: BigNumberish, rhs: BytesLike, scalarByte: BytesLike],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "fheNe(uint256,uint256,bytes1)"
  ): TypedContractMethod<
    [lhs: BigNumberish, rhs: BigNumberish, scalarByte: BytesLike],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "fheNeg"
  ): TypedContractMethod<[ct: BigNumberish], [bigint], "nonpayable">;
  getFunction(
    nameOrSignature: "fheNot"
  ): TypedContractMethod<[ct: BigNumberish], [bigint], "nonpayable">;
  getFunction(
    nameOrSignature: "fheRand"
  ): TypedContractMethod<[randType: BytesLike], [bigint], "nonpayable">;
  getFunction(
    nameOrSignature: "fheRandBounded"
  ): TypedContractMethod<
    [upperBound: BigNumberish, randType: BytesLike],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "fheRem"
  ): TypedContractMethod<
    [lhs: BigNumberish, rhs: BigNumberish, scalarByte: BytesLike],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "fheRotl"
  ): TypedContractMethod<
    [lhs: BigNumberish, rhs: BigNumberish, scalarByte: BytesLike],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "fheRotr"
  ): TypedContractMethod<
    [lhs: BigNumberish, rhs: BigNumberish, scalarByte: BytesLike],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "fheShl"
  ): TypedContractMethod<
    [lhs: BigNumberish, rhs: BigNumberish, scalarByte: BytesLike],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "fheShr"
  ): TypedContractMethod<
    [lhs: BigNumberish, rhs: BigNumberish, scalarByte: BytesLike],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "fheSub"
  ): TypedContractMethod<
    [lhs: BigNumberish, rhs: BigNumberish, scalarByte: BytesLike],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "getACLAddress"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "getFHEPaymentAddress"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "getInputVerifierAddress"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "getVersion"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "initialize"
  ): TypedContractMethod<[initialOwner: AddressLike], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "owner"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "pendingOwner"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "proxiableUUID"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "renounceOwnership"
  ): TypedContractMethod<[], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "transferOwnership"
  ): TypedContractMethod<[newOwner: AddressLike], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "trivialEncrypt(bytes,bytes1)"
  ): TypedContractMethod<
    [pt: BytesLike, toType: BytesLike],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "trivialEncrypt(uint256,bytes1)"
  ): TypedContractMethod<
    [pt: BigNumberish, toType: BytesLike],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "upgradeToAndCall"
  ): TypedContractMethod<
    [newImplementation: AddressLike, data: BytesLike],
    [void],
    "payable"
  >;
  getFunction(
    nameOrSignature: "verifyCiphertext"
  ): TypedContractMethod<
    [
      inputHandle: BytesLike,
      userAddress: AddressLike,
      inputProof: BytesLike,
      inputType: BytesLike
    ],
    [bigint],
    "nonpayable"
  >;

  getEvent(
    key: "Cast"
  ): TypedContractEvent<
    CastEvent.InputTuple,
    CastEvent.OutputTuple,
    CastEvent.OutputObject
  >;
  getEvent(
    key: "FheAdd"
  ): TypedContractEvent<
    FheAddEvent.InputTuple,
    FheAddEvent.OutputTuple,
    FheAddEvent.OutputObject
  >;
  getEvent(
    key: "FheBitAnd"
  ): TypedContractEvent<
    FheBitAndEvent.InputTuple,
    FheBitAndEvent.OutputTuple,
    FheBitAndEvent.OutputObject
  >;
  getEvent(
    key: "FheBitOr"
  ): TypedContractEvent<
    FheBitOrEvent.InputTuple,
    FheBitOrEvent.OutputTuple,
    FheBitOrEvent.OutputObject
  >;
  getEvent(
    key: "FheBitXor"
  ): TypedContractEvent<
    FheBitXorEvent.InputTuple,
    FheBitXorEvent.OutputTuple,
    FheBitXorEvent.OutputObject
  >;
  getEvent(
    key: "FheDiv"
  ): TypedContractEvent<
    FheDivEvent.InputTuple,
    FheDivEvent.OutputTuple,
    FheDivEvent.OutputObject
  >;
  getEvent(
    key: "FheEq"
  ): TypedContractEvent<
    FheEqEvent.InputTuple,
    FheEqEvent.OutputTuple,
    FheEqEvent.OutputObject
  >;
  getEvent(
    key: "FheEqBytes"
  ): TypedContractEvent<
    FheEqBytesEvent.InputTuple,
    FheEqBytesEvent.OutputTuple,
    FheEqBytesEvent.OutputObject
  >;
  getEvent(
    key: "FheGe"
  ): TypedContractEvent<
    FheGeEvent.InputTuple,
    FheGeEvent.OutputTuple,
    FheGeEvent.OutputObject
  >;
  getEvent(
    key: "FheGt"
  ): TypedContractEvent<
    FheGtEvent.InputTuple,
    FheGtEvent.OutputTuple,
    FheGtEvent.OutputObject
  >;
  getEvent(
    key: "FheIfThenElse"
  ): TypedContractEvent<
    FheIfThenElseEvent.InputTuple,
    FheIfThenElseEvent.OutputTuple,
    FheIfThenElseEvent.OutputObject
  >;
  getEvent(
    key: "FheLe"
  ): TypedContractEvent<
    FheLeEvent.InputTuple,
    FheLeEvent.OutputTuple,
    FheLeEvent.OutputObject
  >;
  getEvent(
    key: "FheLt"
  ): TypedContractEvent<
    FheLtEvent.InputTuple,
    FheLtEvent.OutputTuple,
    FheLtEvent.OutputObject
  >;
  getEvent(
    key: "FheMax"
  ): TypedContractEvent<
    FheMaxEvent.InputTuple,
    FheMaxEvent.OutputTuple,
    FheMaxEvent.OutputObject
  >;
  getEvent(
    key: "FheMin"
  ): TypedContractEvent<
    FheMinEvent.InputTuple,
    FheMinEvent.OutputTuple,
    FheMinEvent.OutputObject
  >;
  getEvent(
    key: "FheMul"
  ): TypedContractEvent<
    FheMulEvent.InputTuple,
    FheMulEvent.OutputTuple,
    FheMulEvent.OutputObject
  >;
  getEvent(
    key: "FheNe"
  ): TypedContractEvent<
    FheNeEvent.InputTuple,
    FheNeEvent.OutputTuple,
    FheNeEvent.OutputObject
  >;
  getEvent(
    key: "FheNeBytes"
  ): TypedContractEvent<
    FheNeBytesEvent.InputTuple,
    FheNeBytesEvent.OutputTuple,
    FheNeBytesEvent.OutputObject
  >;
  getEvent(
    key: "FheNeg"
  ): TypedContractEvent<
    FheNegEvent.InputTuple,
    FheNegEvent.OutputTuple,
    FheNegEvent.OutputObject
  >;
  getEvent(
    key: "FheNot"
  ): TypedContractEvent<
    FheNotEvent.InputTuple,
    FheNotEvent.OutputTuple,
    FheNotEvent.OutputObject
  >;
  getEvent(
    key: "FheRand"
  ): TypedContractEvent<
    FheRandEvent.InputTuple,
    FheRandEvent.OutputTuple,
    FheRandEvent.OutputObject
  >;
  getEvent(
    key: "FheRandBounded"
  ): TypedContractEvent<
    FheRandBoundedEvent.InputTuple,
    FheRandBoundedEvent.OutputTuple,
    FheRandBoundedEvent.OutputObject
  >;
  getEvent(
    key: "FheRem"
  ): TypedContractEvent<
    FheRemEvent.InputTuple,
    FheRemEvent.OutputTuple,
    FheRemEvent.OutputObject
  >;
  getEvent(
    key: "FheRotl"
  ): TypedContractEvent<
    FheRotlEvent.InputTuple,
    FheRotlEvent.OutputTuple,
    FheRotlEvent.OutputObject
  >;
  getEvent(
    key: "FheRotr"
  ): TypedContractEvent<
    FheRotrEvent.InputTuple,
    FheRotrEvent.OutputTuple,
    FheRotrEvent.OutputObject
  >;
  getEvent(
    key: "FheShl"
  ): TypedContractEvent<
    FheShlEvent.InputTuple,
    FheShlEvent.OutputTuple,
    FheShlEvent.OutputObject
  >;
  getEvent(
    key: "FheShr"
  ): TypedContractEvent<
    FheShrEvent.InputTuple,
    FheShrEvent.OutputTuple,
    FheShrEvent.OutputObject
  >;
  getEvent(
    key: "FheSub"
  ): TypedContractEvent<
    FheSubEvent.InputTuple,
    FheSubEvent.OutputTuple,
    FheSubEvent.OutputObject
  >;
  getEvent(
    key: "Initialized"
  ): TypedContractEvent<
    InitializedEvent.InputTuple,
    InitializedEvent.OutputTuple,
    InitializedEvent.OutputObject
  >;
  getEvent(
    key: "OwnershipTransferStarted"
  ): TypedContractEvent<
    OwnershipTransferStartedEvent.InputTuple,
    OwnershipTransferStartedEvent.OutputTuple,
    OwnershipTransferStartedEvent.OutputObject
  >;
  getEvent(
    key: "OwnershipTransferred"
  ): TypedContractEvent<
    OwnershipTransferredEvent.InputTuple,
    OwnershipTransferredEvent.OutputTuple,
    OwnershipTransferredEvent.OutputObject
  >;
  getEvent(
    key: "TrivialEncrypt"
  ): TypedContractEvent<
    TrivialEncryptEvent.InputTuple,
    TrivialEncryptEvent.OutputTuple,
    TrivialEncryptEvent.OutputObject
  >;
  getEvent(
    key: "TrivialEncryptBytes"
  ): TypedContractEvent<
    TrivialEncryptBytesEvent.InputTuple,
    TrivialEncryptBytesEvent.OutputTuple,
    TrivialEncryptBytesEvent.OutputObject
  >;
  getEvent(
    key: "Upgraded"
  ): TypedContractEvent<
    UpgradedEvent.InputTuple,
    UpgradedEvent.OutputTuple,
    UpgradedEvent.OutputObject
  >;
  getEvent(
    key: "VerifyCiphertext"
  ): TypedContractEvent<
    VerifyCiphertextEvent.InputTuple,
    VerifyCiphertextEvent.OutputTuple,
    VerifyCiphertextEvent.OutputObject
  >;

  filters: {
    "Cast(uint256,bytes1,uint256)": TypedContractEvent<
      CastEvent.InputTuple,
      CastEvent.OutputTuple,
      CastEvent.OutputObject
    >;
    Cast: TypedContractEvent<
      CastEvent.InputTuple,
      CastEvent.OutputTuple,
      CastEvent.OutputObject
    >;

    "FheAdd(uint256,uint256,bytes1,uint256)": TypedContractEvent<
      FheAddEvent.InputTuple,
      FheAddEvent.OutputTuple,
      FheAddEvent.OutputObject
    >;
    FheAdd: TypedContractEvent<
      FheAddEvent.InputTuple,
      FheAddEvent.OutputTuple,
      FheAddEvent.OutputObject
    >;

    "FheBitAnd(uint256,uint256,bytes1,uint256)": TypedContractEvent<
      FheBitAndEvent.InputTuple,
      FheBitAndEvent.OutputTuple,
      FheBitAndEvent.OutputObject
    >;
    FheBitAnd: TypedContractEvent<
      FheBitAndEvent.InputTuple,
      FheBitAndEvent.OutputTuple,
      FheBitAndEvent.OutputObject
    >;

    "FheBitOr(uint256,uint256,bytes1,uint256)": TypedContractEvent<
      FheBitOrEvent.InputTuple,
      FheBitOrEvent.OutputTuple,
      FheBitOrEvent.OutputObject
    >;
    FheBitOr: TypedContractEvent<
      FheBitOrEvent.InputTuple,
      FheBitOrEvent.OutputTuple,
      FheBitOrEvent.OutputObject
    >;

    "FheBitXor(uint256,uint256,bytes1,uint256)": TypedContractEvent<
      FheBitXorEvent.InputTuple,
      FheBitXorEvent.OutputTuple,
      FheBitXorEvent.OutputObject
    >;
    FheBitXor: TypedContractEvent<
      FheBitXorEvent.InputTuple,
      FheBitXorEvent.OutputTuple,
      FheBitXorEvent.OutputObject
    >;

    "FheDiv(uint256,uint256,bytes1,uint256)": TypedContractEvent<
      FheDivEvent.InputTuple,
      FheDivEvent.OutputTuple,
      FheDivEvent.OutputObject
    >;
    FheDiv: TypedContractEvent<
      FheDivEvent.InputTuple,
      FheDivEvent.OutputTuple,
      FheDivEvent.OutputObject
    >;

    "FheEq(uint256,uint256,bytes1,uint256)": TypedContractEvent<
      FheEqEvent.InputTuple,
      FheEqEvent.OutputTuple,
      FheEqEvent.OutputObject
    >;
    FheEq: TypedContractEvent<
      FheEqEvent.InputTuple,
      FheEqEvent.OutputTuple,
      FheEqEvent.OutputObject
    >;

    "FheEqBytes(uint256,bytes,bytes1,uint256)": TypedContractEvent<
      FheEqBytesEvent.InputTuple,
      FheEqBytesEvent.OutputTuple,
      FheEqBytesEvent.OutputObject
    >;
    FheEqBytes: TypedContractEvent<
      FheEqBytesEvent.InputTuple,
      FheEqBytesEvent.OutputTuple,
      FheEqBytesEvent.OutputObject
    >;

    "FheGe(uint256,uint256,bytes1,uint256)": TypedContractEvent<
      FheGeEvent.InputTuple,
      FheGeEvent.OutputTuple,
      FheGeEvent.OutputObject
    >;
    FheGe: TypedContractEvent<
      FheGeEvent.InputTuple,
      FheGeEvent.OutputTuple,
      FheGeEvent.OutputObject
    >;

    "FheGt(uint256,uint256,bytes1,uint256)": TypedContractEvent<
      FheGtEvent.InputTuple,
      FheGtEvent.OutputTuple,
      FheGtEvent.OutputObject
    >;
    FheGt: TypedContractEvent<
      FheGtEvent.InputTuple,
      FheGtEvent.OutputTuple,
      FheGtEvent.OutputObject
    >;

    "FheIfThenElse(uint256,uint256,uint256,uint256)": TypedContractEvent<
      FheIfThenElseEvent.InputTuple,
      FheIfThenElseEvent.OutputTuple,
      FheIfThenElseEvent.OutputObject
    >;
    FheIfThenElse: TypedContractEvent<
      FheIfThenElseEvent.InputTuple,
      FheIfThenElseEvent.OutputTuple,
      FheIfThenElseEvent.OutputObject
    >;

    "FheLe(uint256,uint256,bytes1,uint256)": TypedContractEvent<
      FheLeEvent.InputTuple,
      FheLeEvent.OutputTuple,
      FheLeEvent.OutputObject
    >;
    FheLe: TypedContractEvent<
      FheLeEvent.InputTuple,
      FheLeEvent.OutputTuple,
      FheLeEvent.OutputObject
    >;

    "FheLt(uint256,uint256,bytes1,uint256)": TypedContractEvent<
      FheLtEvent.InputTuple,
      FheLtEvent.OutputTuple,
      FheLtEvent.OutputObject
    >;
    FheLt: TypedContractEvent<
      FheLtEvent.InputTuple,
      FheLtEvent.OutputTuple,
      FheLtEvent.OutputObject
    >;

    "FheMax(uint256,uint256,bytes1,uint256)": TypedContractEvent<
      FheMaxEvent.InputTuple,
      FheMaxEvent.OutputTuple,
      FheMaxEvent.OutputObject
    >;
    FheMax: TypedContractEvent<
      FheMaxEvent.InputTuple,
      FheMaxEvent.OutputTuple,
      FheMaxEvent.OutputObject
    >;

    "FheMin(uint256,uint256,bytes1,uint256)": TypedContractEvent<
      FheMinEvent.InputTuple,
      FheMinEvent.OutputTuple,
      FheMinEvent.OutputObject
    >;
    FheMin: TypedContractEvent<
      FheMinEvent.InputTuple,
      FheMinEvent.OutputTuple,
      FheMinEvent.OutputObject
    >;

    "FheMul(uint256,uint256,bytes1,uint256)": TypedContractEvent<
      FheMulEvent.InputTuple,
      FheMulEvent.OutputTuple,
      FheMulEvent.OutputObject
    >;
    FheMul: TypedContractEvent<
      FheMulEvent.InputTuple,
      FheMulEvent.OutputTuple,
      FheMulEvent.OutputObject
    >;

    "FheNe(uint256,uint256,bytes1,uint256)": TypedContractEvent<
      FheNeEvent.InputTuple,
      FheNeEvent.OutputTuple,
      FheNeEvent.OutputObject
    >;
    FheNe: TypedContractEvent<
      FheNeEvent.InputTuple,
      FheNeEvent.OutputTuple,
      FheNeEvent.OutputObject
    >;

    "FheNeBytes(uint256,bytes,bytes1,uint256)": TypedContractEvent<
      FheNeBytesEvent.InputTuple,
      FheNeBytesEvent.OutputTuple,
      FheNeBytesEvent.OutputObject
    >;
    FheNeBytes: TypedContractEvent<
      FheNeBytesEvent.InputTuple,
      FheNeBytesEvent.OutputTuple,
      FheNeBytesEvent.OutputObject
    >;

    "FheNeg(uint256,uint256)": TypedContractEvent<
      FheNegEvent.InputTuple,
      FheNegEvent.OutputTuple,
      FheNegEvent.OutputObject
    >;
    FheNeg: TypedContractEvent<
      FheNegEvent.InputTuple,
      FheNegEvent.OutputTuple,
      FheNegEvent.OutputObject
    >;

    "FheNot(uint256,uint256)": TypedContractEvent<
      FheNotEvent.InputTuple,
      FheNotEvent.OutputTuple,
      FheNotEvent.OutputObject
    >;
    FheNot: TypedContractEvent<
      FheNotEvent.InputTuple,
      FheNotEvent.OutputTuple,
      FheNotEvent.OutputObject
    >;

    "FheRand(bytes1,uint256)": TypedContractEvent<
      FheRandEvent.InputTuple,
      FheRandEvent.OutputTuple,
      FheRandEvent.OutputObject
    >;
    FheRand: TypedContractEvent<
      FheRandEvent.InputTuple,
      FheRandEvent.OutputTuple,
      FheRandEvent.OutputObject
    >;

    "FheRandBounded(uint256,bytes1,uint256)": TypedContractEvent<
      FheRandBoundedEvent.InputTuple,
      FheRandBoundedEvent.OutputTuple,
      FheRandBoundedEvent.OutputObject
    >;
    FheRandBounded: TypedContractEvent<
      FheRandBoundedEvent.InputTuple,
      FheRandBoundedEvent.OutputTuple,
      FheRandBoundedEvent.OutputObject
    >;

    "FheRem(uint256,uint256,bytes1,uint256)": TypedContractEvent<
      FheRemEvent.InputTuple,
      FheRemEvent.OutputTuple,
      FheRemEvent.OutputObject
    >;
    FheRem: TypedContractEvent<
      FheRemEvent.InputTuple,
      FheRemEvent.OutputTuple,
      FheRemEvent.OutputObject
    >;

    "FheRotl(uint256,uint256,bytes1,uint256)": TypedContractEvent<
      FheRotlEvent.InputTuple,
      FheRotlEvent.OutputTuple,
      FheRotlEvent.OutputObject
    >;
    FheRotl: TypedContractEvent<
      FheRotlEvent.InputTuple,
      FheRotlEvent.OutputTuple,
      FheRotlEvent.OutputObject
    >;

    "FheRotr(uint256,uint256,bytes1,uint256)": TypedContractEvent<
      FheRotrEvent.InputTuple,
      FheRotrEvent.OutputTuple,
      FheRotrEvent.OutputObject
    >;
    FheRotr: TypedContractEvent<
      FheRotrEvent.InputTuple,
      FheRotrEvent.OutputTuple,
      FheRotrEvent.OutputObject
    >;

    "FheShl(uint256,uint256,bytes1,uint256)": TypedContractEvent<
      FheShlEvent.InputTuple,
      FheShlEvent.OutputTuple,
      FheShlEvent.OutputObject
    >;
    FheShl: TypedContractEvent<
      FheShlEvent.InputTuple,
      FheShlEvent.OutputTuple,
      FheShlEvent.OutputObject
    >;

    "FheShr(uint256,uint256,bytes1,uint256)": TypedContractEvent<
      FheShrEvent.InputTuple,
      FheShrEvent.OutputTuple,
      FheShrEvent.OutputObject
    >;
    FheShr: TypedContractEvent<
      FheShrEvent.InputTuple,
      FheShrEvent.OutputTuple,
      FheShrEvent.OutputObject
    >;

    "FheSub(uint256,uint256,bytes1,uint256)": TypedContractEvent<
      FheSubEvent.InputTuple,
      FheSubEvent.OutputTuple,
      FheSubEvent.OutputObject
    >;
    FheSub: TypedContractEvent<
      FheSubEvent.InputTuple,
      FheSubEvent.OutputTuple,
      FheSubEvent.OutputObject
    >;

    "Initialized(uint64)": TypedContractEvent<
      InitializedEvent.InputTuple,
      InitializedEvent.OutputTuple,
      InitializedEvent.OutputObject
    >;
    Initialized: TypedContractEvent<
      InitializedEvent.InputTuple,
      InitializedEvent.OutputTuple,
      InitializedEvent.OutputObject
    >;

    "OwnershipTransferStarted(address,address)": TypedContractEvent<
      OwnershipTransferStartedEvent.InputTuple,
      OwnershipTransferStartedEvent.OutputTuple,
      OwnershipTransferStartedEvent.OutputObject
    >;
    OwnershipTransferStarted: TypedContractEvent<
      OwnershipTransferStartedEvent.InputTuple,
      OwnershipTransferStartedEvent.OutputTuple,
      OwnershipTransferStartedEvent.OutputObject
    >;

    "OwnershipTransferred(address,address)": TypedContractEvent<
      OwnershipTransferredEvent.InputTuple,
      OwnershipTransferredEvent.OutputTuple,
      OwnershipTransferredEvent.OutputObject
    >;
    OwnershipTransferred: TypedContractEvent<
      OwnershipTransferredEvent.InputTuple,
      OwnershipTransferredEvent.OutputTuple,
      OwnershipTransferredEvent.OutputObject
    >;

    "TrivialEncrypt(uint256,bytes1,uint256)": TypedContractEvent<
      TrivialEncryptEvent.InputTuple,
      TrivialEncryptEvent.OutputTuple,
      TrivialEncryptEvent.OutputObject
    >;
    TrivialEncrypt: TypedContractEvent<
      TrivialEncryptEvent.InputTuple,
      TrivialEncryptEvent.OutputTuple,
      TrivialEncryptEvent.OutputObject
    >;

    "TrivialEncryptBytes(bytes,bytes1,uint256)": TypedContractEvent<
      TrivialEncryptBytesEvent.InputTuple,
      TrivialEncryptBytesEvent.OutputTuple,
      TrivialEncryptBytesEvent.OutputObject
    >;
    TrivialEncryptBytes: TypedContractEvent<
      TrivialEncryptBytesEvent.InputTuple,
      TrivialEncryptBytesEvent.OutputTuple,
      TrivialEncryptBytesEvent.OutputObject
    >;

    "Upgraded(address)": TypedContractEvent<
      UpgradedEvent.InputTuple,
      UpgradedEvent.OutputTuple,
      UpgradedEvent.OutputObject
    >;
    Upgraded: TypedContractEvent<
      UpgradedEvent.InputTuple,
      UpgradedEvent.OutputTuple,
      UpgradedEvent.OutputObject
    >;

    "VerifyCiphertext(bytes32,address,bytes,bytes1,uint256)": TypedContractEvent<
      VerifyCiphertextEvent.InputTuple,
      VerifyCiphertextEvent.OutputTuple,
      VerifyCiphertextEvent.OutputObject
    >;
    VerifyCiphertext: TypedContractEvent<
      VerifyCiphertextEvent.InputTuple,
      VerifyCiphertextEvent.OutputTuple,
      VerifyCiphertextEvent.OutputObject
    >;
  };
}
